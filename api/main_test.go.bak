package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"
)

// setupTestServer creates a test server with a given API instance
func setupTestServer(api *HardwareAPI) *httptest.Server {
	// Create a new ServeMux for each test
	mux := http.NewServeMux()

	// Register handlers on the custom mux instead of DefaultServeMux
	mux.HandleFunc("/status", api.handleStatus)
	mux.HandleFunc("/devices", api.handleDevices)
	mux.HandleFunc("/jobs", api.handleJobs)
	mux.HandleFunc("/queue-job", api.handleQueueJob)
	mux.HandleFunc("/health", api.handleHealth)
	mux.HandleFunc("/device/logs", api.handleDeviceLogs)
	mux.HandleFunc("/sat-jobs", api.handleSatJobs)
	mux.HandleFunc("/submit-sat-job", api.handleSubmitSatJob)
	mux.HandleFunc("/sat-job/", api.handleSatJobStatus)

	return httptest.NewServer(mux)
}

// TestSatJobSubmissionAndRetrieval tests the complete flow of submitting a SAT job
// and retrieving its status
func TestSatJobSubmissionAndRetrieval(t *testing.T) {
	fmt.Printf("Test: SAT job submission and retrieval ...\n")

	// Setup API
	api := NewHardwareAPI()

	// Add simulated device
	simDev := NewSimulatedDevice("test-device-001")
	simDev.Start()
	api.mutex.Lock()
	api.simulatedDevices["test-device-001"] = simDev
	api.mutex.Unlock()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Create a simple CNF job
	cnfContent := `p cnf 3 2
1 2 3 0
-1 -2 0`

	// Build job request
	jobRequest := SatJob{
		CNFFile:     cnfContent,
		MaxSteps:    1000,
		Probability: 0.5,
		MaxUnsat:    0,
		Seed:        42,
		CutoffTime:  5,
	}

	// Marshal to JSON
	jobJSON, err := json.Marshal(jobRequest)
	if err != nil {
		t.Fatalf("Failed to marshal job request: %v", err)
	}

	// Submit job
	resp, err := http.Post(
		server.URL+"/submit-sat-job",
		"application/json",
		bytes.NewBuffer(jobJSON),
	)
	if err != nil {
		t.Fatalf("Failed to submit job: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var submitResp map[string]string
	if err := json.NewDecoder(resp.Body).Decode(&submitResp); err != nil {
		t.Fatalf("Failed to decode response: %v", err)
	}

	jobID, ok := submitResp["job_id"]
	if !ok {
		t.Fatalf("Response missing job_id field")
	}

	// Give the job some time to process
	time.Sleep(2 * time.Second)

	// Check job status
	statusURL := fmt.Sprintf("%s/sat-job/%s", server.URL, jobID)
	statusResp, err := http.Get(statusURL)
	if err != nil {
		t.Fatalf("Failed to get job status: %v", err)
	}
	defer statusResp.Body.Close()

	if statusResp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", statusResp.StatusCode)
	}

	var jobStatus SatJob
	if err := json.NewDecoder(statusResp.Body).Decode(&jobStatus); err != nil {
		t.Fatalf("Failed to decode job status: %v", err)
	}

	// Verify job was processed
	if jobStatus.Status != "running" && jobStatus.Status != "completed" {
		t.Errorf("Expected job status 'running' or 'completed', got '%s'", jobStatus.Status)
	}

	// Check that job has a device assigned
	if jobStatus.DeviceID == "" {
		t.Errorf("Job not assigned to any device")
	}

	fmt.Printf("  ... Passed\n")
}

// TestDevicesEndpoint checks if we can get a list of devices
func TestDevicesEndpoint(t *testing.T) {
	fmt.Printf("Test: Devices endpoint ...\n")

	api := NewHardwareAPI()

	// Add a real device
	api.devices["real-device-001"] = DeviceStatus{
		ID:           "real-device-001",
		Name:         "Test Real Device",
		Status:       "idle",
		Connected:    true,
		Capabilities: []string{"sat"},
	}

	// Add simulated device
	simDev := NewSimulatedDevice("sim-device-001")
	simDev.Start()
	api.mutex.Lock()
	api.simulatedDevices["sim-device-001"] = simDev
	api.mutex.Unlock()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Get devices
	resp, err := http.Get(server.URL + "/devices")
	if err != nil {
		t.Fatalf("Failed to get devices: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var devices []DeviceStatus
	if err := json.NewDecoder(resp.Body).Decode(&devices); err != nil {
		t.Fatalf("Failed to decode devices: %v", err)
	}

	// Verify we have both real and simulated devices
	if len(devices) != 2 {
		t.Fatalf("Expected 2 devices, got %d", len(devices))
	}

	// Verify real device is present
	foundReal := false
	foundSim := false
	for _, d := range devices {
		if d.ID == "real-device-001" {
			foundReal = true
		}
		if d.ID == "sim-device-001" {
			foundSim = true
		}
	}

	if !foundReal {
		t.Errorf("Real device not found in /devices endpoint")
	}
	if !foundSim {
		t.Errorf("Simulated device not found in /devices endpoint")
	}

	fmt.Printf("  ... Passed\n")
}

// TestDeviceLogsEndpoint checks if we can retrieve logs from a device
func TestDeviceLogsEndpoint(t *testing.T) {
	fmt.Printf("Test: Device logs retrieval ...\n")

	api := NewHardwareAPI()

	// Add simulated device
	simDev := NewSimulatedDevice("log-device-001")
	simDev.Start()

	// Manually add some logs
	simDev.LogMutex.Lock()
	simDev.Logs = append(simDev.Logs, "Test log entry 1")
	simDev.Logs = append(simDev.Logs, "Test log entry 2")
	simDev.LogMutex.Unlock()

	api.mutex.Lock()
	api.simulatedDevices["log-device-001"] = simDev
	api.mutex.Unlock()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Get logs
	resp, err := http.Get(server.URL + "/device/logs?id=log-device-001")
	if err != nil {
		t.Fatalf("Failed to get device logs: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var logs []string
	if err := json.NewDecoder(resp.Body).Decode(&logs); err != nil {
		t.Fatalf("Failed to decode logs: %v", err)
	}

	// Verify logs are present
	if len(logs) < 2 {
		t.Fatalf("Expected at least 2 log entries, got %d", len(logs))
	}

	// Check for our test log entries
	found1 := false
	found2 := false
	for _, log := range logs {
		if log == "Test log entry 1" {
			found1 = true
		}
		if log == "Test log entry 2" {
			found2 = true
		}
	}

	if !found1 || !found2 {
		t.Errorf("Test log entries not found in device logs")
	}

	fmt.Printf("  ... Passed\n")
}

// TestStatusEndpoint verifies that the status endpoint returns correct information
func TestStatusEndpoint(t *testing.T) {
	fmt.Printf("Test: Status endpoint ...\n")

	api := NewHardwareAPI()

	// Add some devices and jobs to the API
	api.devices["status-device-001"] = DeviceStatus{
		ID:           "status-device-001",
		Name:         "Status Test Device",
		Status:       "idle",
		Connected:    true,
		Capabilities: []string{"sat"},
	}

	// Add a job
	api.jobs["job-001"] = Job{
		ID:        "job-001",
		DeviceID:  "status-device-001",
		TestType:  "sat",
		Status:    "completed",
		CreatedAt: time.Now().Add(-10 * time.Minute),
	}

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Get status
	resp, err := http.Get(server.URL + "/status")
	if err != nil {
		t.Fatalf("Failed to get status: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var status map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&status); err != nil {
		t.Fatalf("Failed to decode status: %v", err)
	}

	// Verify status fields
	if status["status"] != "online" {
		t.Errorf("Expected status 'online', got '%v'", status["status"])
	}

	if status["device_count"] != float64(1) {
		t.Errorf("Expected device_count 1, got %v", status["device_count"])
	}

	if status["job_count"] != float64(1) {
		t.Errorf("Expected job_count 1, got %v", status["job_count"])
	}

	fmt.Printf("  ... Passed\n")
}

// TestHealthEndpoint checks if the health endpoint is responding
func TestHealthEndpoint(t *testing.T) {
	fmt.Printf("Test: Health check endpoint ...\n")

	api := NewHardwareAPI()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Get health status
	resp, err := http.Get(server.URL + "/health")
	if err != nil {
		t.Fatalf("Failed to get health status: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var health map[string]string
	if err := json.NewDecoder(resp.Body).Decode(&health); err != nil {
		t.Fatalf("Failed to decode health status: %v", err)
	}

	// Verify health status
	if health["status"] != "OK" {
		t.Errorf("Expected health status 'OK', got '%s'", health["status"])
	}

	fmt.Printf("  ... Passed\n")
}

// TestSatJobsEndpoint verifies that the sat-jobs endpoint returns correct information
func TestSatJobsEndpoint(t *testing.T) {
	fmt.Printf("Test: SAT jobs listing ...\n")

	api := NewHardwareAPI()

	// Add some SAT jobs to the API
	testJob := SatJob{
		ID:          "sat-job-001",
		DeviceID:    "test-device",
		Status:      "completed",
		CNFFile:     "test.cnf",
		MaxSteps:    1000,
		Probability: 0.5,
		CreatedAt:   time.Now().Add(-20 * time.Minute),
		CompletedAt: time.Now().Add(-15 * time.Minute),
	}

	api.mutex.Lock()
	api.satJobs["sat-job-001"] = testJob
	api.mutex.Unlock()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Get SAT jobs
	resp, err := http.Get(server.URL + "/sat-jobs")
	if err != nil {
		t.Fatalf("Failed to get SAT jobs: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		t.Fatalf("Expected status 200, got %d", resp.StatusCode)
	}

	var jobs []SatJob
	if err := json.NewDecoder(resp.Body).Decode(&jobs); err != nil {
		t.Fatalf("Failed to decode SAT jobs: %v", err)
	}

	// Verify we have our test job
	if len(jobs) != 1 {
		t.Fatalf("Expected 1 SAT job, got %d", len(jobs))
	}

	if jobs[0].ID != "sat-job-001" {
		t.Errorf("Expected job ID 'sat-job-001', got '%s'", jobs[0].ID)
	}

	if jobs[0].Status != "completed" {
		t.Errorf("Expected job status 'completed', got '%s'", jobs[0].Status)
	}

	fmt.Printf("  ... Passed\n")
}

// TestQueueJobNotImplemented verifies that the queue-job endpoint returns 501 Not Implemented
func TestQueueJobNotImplemented(t *testing.T) {
	fmt.Printf("Test: Queue job not implemented ...\n")

	api := NewHardwareAPI()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Try to queue a job
	resp, err := http.Get(server.URL + "/queue-job")
	if err != nil {
		t.Fatalf("Failed to call queue-job endpoint: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNotImplemented {
		t.Fatalf("Expected status 501 (Not Implemented), got %d", resp.StatusCode)
	}

	fmt.Printf("  ... Passed\n")
}

// TestInvalidJobID verifies that the sat-job endpoint returns 404 Not Found for invalid job IDs
func TestInvalidJobID(t *testing.T) {
	fmt.Printf("Test: Invalid job ID handling ...\n")

	api := NewHardwareAPI()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Try to get a non-existent job
	resp, err := http.Get(server.URL + "/sat-job/non-existent-job-id")
	if err != nil {
		t.Fatalf("Failed to call sat-job endpoint: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNotFound {
		t.Fatalf("Expected status 404 (Not Found), got %d", resp.StatusCode)
	}

	fmt.Printf("  ... Passed\n")
}

// TestDeviceLogsWithoutID verifies that the device/logs endpoint returns 400 Bad Request when no device ID is provided
func TestDeviceLogsWithoutID(t *testing.T) {
	fmt.Printf("Test: Device logs without ID parameter ...\n")

	api := NewHardwareAPI()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Try to get logs without specifying a device ID
	resp, err := http.Get(server.URL + "/device/logs")
	if err != nil {
		t.Fatalf("Failed to call device/logs endpoint: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusBadRequest {
		t.Fatalf("Expected status 400 (Bad Request), got %d", resp.StatusCode)
	}

	fmt.Printf("  ... Passed\n")
}

// TestDeviceLogsWithInvalidID verifies that the device/logs endpoint returns 404 Not Found for invalid device IDs
func TestDeviceLogsWithInvalidID(t *testing.T) {
	fmt.Printf("Test: Device logs with invalid ID ...\n")

	api := NewHardwareAPI()

	// Setup test server with custom mux
	server := setupTestServer(api)
	defer server.Close()

	// Try to get logs for a non-existent device
	resp, err := http.Get(server.URL + "/device/logs?id=non-existent-device-id")
	if err != nil {
		t.Fatalf("Failed to call device/logs endpoint: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNotFound {
		t.Fatalf("Expected status 404 (Not Found), got %d", resp.StatusCode)
	}

	fmt.Printf("  ... Passed\n")
}

// TestConcurrentSubmissions tests submitting multiple SAT jobs concurrently
func TestConcurrentSubmissions(t *testing.T) {
	fmt.Printf("Test: Concurrent SAT job submissions ...\n")

	api := NewHardwareAPI()

	// Add multiple simulated devices
	for i := 0; i < 3; i++ {
		deviceID := fmt.Sprintf("concurrent-device-%03d", i)
		simDev := NewSimulatedDevice(deviceID)
		simDev.Start()
		api.mutex.Lock()
		api.simulatedDevices[deviceID] = simDev
		api.mutex.Unlock()
	}

	// Setup test server
	server := setupTestServer(api)
	defer server.Close()

	// Simple CNF content
	cnfContent := `p cnf 3 2
1 2 3 0
-1 -2 0`

	// Submit jobs concurrently
	const numJobs = 5
	jobIDs := make(chan string, numJobs)

	for i := 0; i < numJobs; i++ {
		go func(jobNum int) {
			// Build job request
			jobRequest := SatJob{
				CNFFile:     cnfContent,
				MaxSteps:    1000,
				Probability: 0.5,
				MaxUnsat:    0,
				Seed:        int64(jobNum),
				CutoffTime:  5,
			}

			jobJSON, err := json.Marshal(jobRequest)
			if err != nil {
				t.Errorf("Failed to marshal job request: %v", err)
				jobIDs <- ""
				return
			}

			resp, err := http.Post(
				server.URL+"/submit-sat-job",
				"application/json",
				bytes.NewBuffer(jobJSON),
			)
			if err != nil {
				t.Errorf("Failed to submit job: %v", err)
				jobIDs <- ""
				return
			}
			defer resp.Body.Close()

			var submitResp map[string]string
			if err := json.NewDecoder(resp.Body).Decode(&submitResp); err != nil {
				t.Errorf("Failed to decode response: %v", err)
				jobIDs <- ""
				return
			}

			jobIDs <- submitResp["job_id"]
		}(i)
	}

	// Collect job IDs
	ids := make([]string, 0, numJobs)
	for i := 0; i < numJobs; i++ {
		id := <-jobIDs
		if id != "" {
			ids = append(ids, id)
		}
	}

	if len(ids) != numJobs {
		t.Fatalf("Expected %d successful job submissions, got %d", numJobs, len(ids))
	}

	// Allow time for jobs to be processed
	time.Sleep(3 * time.Second)

	// Verify all jobs were scheduled
	api.mutex.Lock()
	jobCount := len(api.satJobs)
	api.mutex.Unlock()

	if jobCount != numJobs {
		t.Errorf("Expected %d jobs in API, found %d", numJobs, jobCount)
	}

	// Verify each job was assigned to a device
	for _, id := range ids {
		statusURL := fmt.Sprintf("%s/sat-job/%s", server.URL, id)
		resp, err := http.Get(statusURL)
		if err != nil {
			t.Fatalf("Failed to get job status: %v", err)
		}

		var jobStatus SatJob
		if err := json.NewDecoder(resp.Body).Decode(&jobStatus); err != nil {
			t.Fatalf("Failed to decode job status: %v", err)
		}
		resp.Body.Close()

		if jobStatus.DeviceID == "" {
			t.Errorf("Job %s not assigned to any device", id)
		}

		if jobStatus.Status != "running" && jobStatus.Status != "completed" {
			t.Errorf("Job %s has unexpected status: %s", id, jobStatus.Status)
		}
	}

	fmt.Printf("  ... Passed\n")
}

func TestHandleGetTestCNF(t *testing.T) {
	// Create test directory structure
	tmpDir := t.TempDir()
	presetDir := filepath.Join(tmpDir, "presets", "test_preset")
	err := os.MkdirAll(presetDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create test directory: %v", err)
	}

	// Create test CNF file
	testCNFContent := "c Test CNF file\np cnf 3 3\n1 2 3 0\n-1 -2 3 0\n1 -2 -3 0\n"
	err = os.WriteFile(filepath.Join(presetDir, "test.cnf"), []byte(testCNFContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create test CNF file: %v", err)
	}

	// Save original presetsDir and restore it after test
	originalPresetsDir := presetsDir
	presetsDir = filepath.Join(tmpDir, "presets")
	defer func() { presetsDir = originalPresetsDir }()

	// Test by name
	req, err := http.NewRequest("GET", "/get-test-cnf?preset=test_preset&test=test.cnf", nil)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}
	rr := httptest.NewRecorder()
	handleGetTestCNF(rr, req)

	// Check response
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Handler returned wrong status code: got %v want %v", status, http.StatusOK)
	}

	var response map[string]interface{}
	err = json.Unmarshal(rr.Body.Bytes(), &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Verify response contents
	if response["filename"] != "test.cnf" {
		t.Errorf("Expected filename 'test.cnf', got '%v'", response["filename"])
	}
	if response["preset"] != "test_preset" {
		t.Errorf("Expected preset 'test_preset', got '%v'", response["preset"])
	}
	if response["cnf"] != testCNFContent {
		t.Errorf("Expected CNF content '%s', got '%v'", testCNFContent, response["cnf"])
	}

	// Test by index
	req, err = http.NewRequest("GET", "/get-test-cnf?preset=test_preset&index=0", nil)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}
	rr = httptest.NewRecorder()
	handleGetTestCNF(rr, req)

	// Check response
	if status := rr.Code; status != http.StatusOK {
		t.Errorf("Handler returned wrong status code: got %v want %v", status, http.StatusOK)
	}

	response = nil
	err = json.Unmarshal(rr.Body.Bytes(), &response)
	if err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	// Verify response
	if response["filename"] != "test.cnf" {
		t.Errorf("Expected filename 'test.cnf', got '%v'", response["filename"])
	}
}

func TestHandleGetTestCNFWithMissingParams(t *testing.T) {
	// Test missing preset
	req, err := http.NewRequest("GET", "/get-test-cnf?test=test.cnf", nil)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}
	rr := httptest.NewRecorder()
	handleGetTestCNF(rr, req)

	// Should get bad request for missing preset
	if status := rr.Code; status != http.StatusBadRequest {
		t.Errorf("Handler returned wrong status code: got %v want %v", status, http.StatusBadRequest)
	}

	// Test missing test and index
	req, err = http.NewRequest("GET", "/get-test-cnf?preset=test_preset", nil)
	if err != nil {
		t.Fatalf("Failed to create request: %v", err)
	}
	rr = httptest.NewRecorder()
	handleGetTestCNF(rr, req)

	// Should get bad request for missing test and index
	if status := rr.Code; status != http.StatusBadRequest {
		t.Errorf("Handler returned wrong status code: got %v want %v", status, http.StatusBadRequest)
	}
}
